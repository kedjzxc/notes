Объект - это спецаильный тип данных, в которых хранятся коллекции или более сложные структуры. Объявление объекта с помощью фигурных скобок называется литералом объекта. Для обращения к свойствам объекта используется точка user.name. Можно обратиться к свойству, которого не сущетсвует и никакой ошибки выведено не будет, будет возвращено undefined. Это позволяет просто проверить существование свойства. Также существует специальный опратор in для проверки существования свойства в объекте. 

let user = { name: "John", age: 30 };

alert( "age" in user ); // true
alert( "blabla" in user ); // false
Для перебора всех свойств объекта испольpуется цикл for...in.
--
Одно из главных отличий объектов от примитивов заключается в том, что они хранятся и копируются по ссылке. Копирование объектной переменной создает еще одну ссылку на тот же объект.
Для клонирования объектов можно использовать специальный метод Object.assign. 
let user = {
    name: 'John',
    age: 30
}

let clone = Object.assign({}, user)
Для глубоко копирования объектов существует специальный метод structeredClone
const developerUserCopy = structuredClone(deleoperUser)
Функции, объявленные в качестве свойства объекта называются методом объекта. Зачастую этим методам необходим доступ к информации внутри объекта. Для этого метод может использовать ключевое слово this
--
Объекты также могут быть созданы с помощью функции конструктора, которые по соглашению именуются с заглавной буквы
function MakeUser(name, age) {
    this.name = name
    this.age = age
}

let user = new MakeUser('Kirill', 19)
Когда функция вызывается как new User(...), происходит следующее:
1) Создается новый пустой объект, и он присваивается this
2) Выполняется тело функции, которое обычно модифицирует this
3) Возвращается значение this
Обычно конструкторы не имеют оператора return. Но если он есть и он возвращает объект, то вместо this вернется объект. Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.
--
Опциональная цепочка ?.
Опциональная цепочка - это безопасный способ доступа к свойстав вложеннных объектов, даже если какое-либо из промежуточных свойств не существует
let user = {}; // пользователь без свойства "address"
alert(user.address.street); // 
Этот код завершится ошибкой так как user.address имеет undefined
Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null
let user = {}
console.log(user?.address?.street); // undefined вместо ошибки
Опциональная цепочка может также работать с функциями и квадратными скобками
?.() используется для вызова функции, которая может не существовать
let userAdmin = {
  admin() {
    alert("Я админ");
  }
};

let userGuest = {};

userAdmin.admin?.(); // Я админ

userGuest.admin?.(); // такого метода нет
--
СИМВОЛ
По спецификации в качестве ключей для свойств объекта могут использоваться только строки.
Символы представляют собой уникальный идентификатор. Создаются с помощью функции Symbol()
let id = Symbol() При создании символу может быть присвоено описание в кавычках Symbol('id')
Символы гарантировано являются уникальными. Даже если мы создадим символ с одинаковым описанием это все равно будут разные символы.
Если мы хотим использовать символ в литеральном объявлении объекта, его необходимо заключить в квадратные скобки.
let id = Symbol('id')
let user = {
    name: 'VASYA',
    [id]: 123
}
Свойства, чьи ключи - символы не перебираются циклом for in. Но Object.assign копирует и строковые и символьные свойста
--
Результатом сложения двух объектов не может быть другой объект