Замыкания - это комбинация функции и лексического окружения
У глобального лексического окружения нет внешнего окружения, так что она указывает на null
Function Declaration инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создается лексическое окржуение. Именно поэтому мы можем обратиться к ним, до того как они определены
\\Внутреннее и внешнее лексическое окружение
let phrase = 'hello'

function say(userName: string) {
    console.log(`${phrase}, ${userName}`);   
}
say('John')

В процессе вызова функции есть два лексических окружения: внутренее(для вызываемой функции) и внешнее(глобальное)
В данном случае во внутреннем находится переменная **userName**, а во внешнем **phrase**
У внутреннего лексического окружения есть ссылка на внешнее
--
*Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.*
--
*Функция получает текущее значение внешних переменных, то есть их последнее значение*
--
Для каждого вызова функции создается собственное лексическое окружение, это хорошо видно на примере:
function makeCounter() {
    let count = 0;
    return function () {
        return count++;
    };
}
let counter1 = makeCounter();
let counter2 = makeCounter();
console.log(counter1()); // 0
console.log(counter1()); // 1
console.log(counter2()); // 0
Для каждого вызова makeCounter() создается новое лексическое окружение функции, со своим собственным count. Так что получившиеся функции counter - независимы
--
Все функции "при рождении" получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были вызваны.
--
Лексическое окружение существует для любых блоков кода {...}
