АСИНХРОННЫЙ КОД
При вызове какой-то функции она попадает в стек вызовов. Стек - это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым (LIFO).
function outer() {
  function inner() {
    console.log('Hello');
  }

  inner()
}

outer()

сначала мы вызываем функцию outer(), она попадает в стек:
1 outer
потом мы вызываем функцию inner(), теперь в стеке две функции:
1 inner
2 outer
теперь мы вызываем console.log() и теперь в стеке три функции:
1 console.log
2 inner
3 outer
как только console.log() выполнится она уйдет из стека:
1 inner
2 outer
выполнившись, функция inner() тоже уйдет из стека, в нем останется лишь:
1 outer
После выполнения всего блока код станет пустым
--
СТЕК В АСИНХРОННОМ КОДЕ
function main() {
  setTimeout(function greet() {
    console.log('hello');
  }, 2000)

  console.log('Bye!');
}

main()

Сначала в стек попадает:
1 main
Вызываем setTimeout()
1 setTimeout
2 main
setTimeout() завершается и выходит из стека:
1 main()
Вызываем console.log('Bye!'), стек:
1 console.log('Bye!')
2 main()
Его вызов завершен, он выходит из стека
1 main()
Вызов main() тоже завершен, стек становится пустым
Проходит 2 секунды, вызывается функця greet(), она попадает в стек:
1 greet()
Она вызывает console.log('Hello!')
1 console.log('Hello!')
2 greet()
console.log('Hello!') выполняется и уходит из стека
1 greet()
После выполнения всего блока стек становится пустым
--
ЦИКЛ СОБЫТИЙ

Он отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач. Цикл событий ответственнен за то, что setTimeout() пропал из стека в прошлом примере. Стоит сказать еще о том, что setTimeout() - это не JavaScript, это Web API. Управление Web API берет на себя Event Loop(цикл событий). Web API использует очередь задач, для хранения того, что нужно выполнить. Когда setTimeout() исчезает из стека, он попадает в видимость Web API, где интерпретатор понимает, что внутри есть функция greet(), которую надо выполнить через 2 секунды. После того, как 2 секунды прошли - функция greet() перемещается в очередь задач. После цикл событий перемещает функцию greet() из списка задач в вызов.
Вызовы из стека и из очереди задач выполняется по-разному. В стеке по принципу LIFO, в очереди по принципу FIFO
--
КОЛБЭКИ
колбэк - это первый способ обработать какое-либо асинхронное действие. У использования колбэков есть один минус - это ад колбэков
--
ПРОМИСЫ
промисы - второй способ работы с асихронным кодом. Промисы - это обертка над асинхронным кодом. Синтаксис:
let promise = new Promise((resolve, reject) => {

})
Когда промис создается, он запускается автоматически. Аргументы resolve и reject - это колбэки. resolve() вызывается в ответ на успешное завершение работы, а reject() в ответ на ошибку.
У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
Состояние промиса может быть изменено только один раз, все остальные вызовы будут проигнорированы. Функции resolve, reject ожидают только одного аргумента, либо ни одного, все остальные будут проигнорированы
--
метод .then() - функция, которая выполняется, когда промис переходит в состояние "выполнен успешно", и получает результат. Второй аргумент .then - функция, которая выполняется, когда промис переходит в состояние "выполнен с ошибкой". Но для обработки ошибок лучше использовать метод catch(), метод finally() выполнится в любом случае, вне зависимости от того успешно или неудано завершен промис. Обработчик, вызванный из finally не принимает аргументов
--
ЦЕПОЧКА ПРОМИСОВ

Результат первого промиса передается по цепочку обработчиков .then. Вызов promise.then тоже возвращает промис, поэтому мы можем вызвать на нем then
--
ОБРАБОТКА ОШИБОК В ПРОМИСАХ

Если бросить ошибку throw из .then(), то промис будет считаться отклоненным, и управление перейдет к ближайшему обработчику ошибок

Пробрасывание ошибок

Если мы пробросим ошибку в блоке catch(), то управление перейдет к следующему ближайшему блоку catch(). А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик then()
--
МЕТОДЫ ПРОМИСОВ

Метод All([массив промисов]) используется, когда нужно запустить несколько промисов параллельно и дождаться их выполнения. Этот метод возвращает новый промис, который будет выполнен, когда будут выполнены все промисы, переданные в виде перечисляемого аргумента. Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.
Метод allSettled() ждет выполнения всех промисов, при этом неважно, завершились ли они успешно или с ошибкой
const promises = [
  new Promise(resolve => setTimeout(() => resolve(1), 3000)),
  new Promise((resolve, reject) => setTimeout(() => reject('error'), 2000)),
  new Promise(resolve => setTimeout(() => resolve(3), 1000))
]

Promise.allSettled(promises)
  .then(([response1, response2, response3]) => {
    console.log(response1)
    // { status: 'fulfilled', value: 3 }
    console.log(response2)
    // { status: 'rejected', reason: 'error' }
    console.log(response3)
    // { status: 'fulfilled', value: 1 }
})
Если промис завершился успешно, то на выходе получаем объект с двумя свойствами {status: 'fulfilled', value: значение}. Если промис завершился с отказом, то получаем объект с двумя свойствами {status: 'rejected', reason: значение}

Метод race() возвращает первый выполненный промис
Метод any() возвращает первый успешно выполненный промис
--
ASYNC/AWAIT

async function f() {
  return 1
}
функция, которая объявлена через async всегда возвращает промис, т.е на это функции можно вызвать catch(), then(), finally(). Слово await заставояет интерпретатор JS ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернет его результат, и выполнение кода продолжится
