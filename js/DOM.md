DOM - Document Object Model, объектная модель документа, которая представляет все содержимое страницы в виде объектов, которыми можно управлять.
Теги явлются узлами-элементами(или просто элементами), а текст внутри элементов образует текстовые узлы.
Если браузер сталкивается с неккореткно написанным HTML, он автоматически корректирует его при построении DOM(т.е если отстувуют, например, теги <html> или <body> браузер их создат)
--
Дочерние узлы (дети) - элементы, которые являются непосредственно детьми узла. Другими словами, это элементы, которые лежат непосредственно внутри данного элемента.
Потомки - все элементы, которые лежат внутри данного, включая детей

<html>
<body>
  <div>Начало</div>

  <ul>
    <li>
      <b>Информация</b>
    </li>
  </ul>
</body>
</html>
В этом случае дети: div, ul, потомки - div, ul, li
Коллекция childNodes содержит список всех детей, включая текстовые узлы. Быстрый доступ к первому или последнему элементу можно получить с помощью firstChild или lastChild
childsNodes похож на массив, но им не является. На самом деле это коллекция - особый перебираемый псевсдомассив. Для перебора коллекции мы можем использовать for of. И также мы не можем использовать методы массивы на коллекции.
--
Соседи - это узлы, у которых один и тот же родитель.
Например, здесь <head> и <body> соседи:
<html>
  <head>...</head><body>...</body>
</html>
Родитель доступен через parentNode
--
РАЗЛИЧИЯ МЕЖДУ HTMLСollection и NodeList
getElementsByClassName возвращает HTML-коллекцию, а querySelectorAll возврщает NodeList.
Разница между ними в том, что HTMLСollection представляет собой динамическую структуру данных, а NodeList - статическую структуру данных. То есть HTMLCollection обновляется каждый раз, когда меняется количество элементов, полученных с помощью соответствующего метода. А NodeList не меняется после формирования, даже если меняется HTML-код страницы.
--
Метод elem.matches() ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору. Этот метод удобен тогда, когды мы перебираем элементы и пытаемся выбрать те из них, которые нас интересуют
Метод closest() поднимается вверх от элемента и проверяет каждого из родителей, если он соответствует передаваемому в closest(/селектор/) селектору, поиск прекращается и он возвращает его
--
innerHTML позволяет получить html-содержимое элемента в виде строки. И также позволяет изменить его.
innerHTML += осуществляет перезапись. Мы можем добавить HTML к элементу, используя elem.innerHTML += 'еще HTML'.Другими словами, innerHTML+= делает следующее:
Старое содержимое удаляется.
На его место становится новое значение innerHTML (с добавленной строкой).

outerHTML - это HTML элемент целиком. В отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.
свойство innerHTML есть только у узлов-элементов.
nodeValue/data: содержимое текстового узла
если мы хотим просто изменить текст внутри элемента, можно использовать textContent.
--
АТРИБУТЫ
Все атрибуты доступны с помощью следующих методов:
elem.hasAttribute(name) – проверяет наличие атрибута.
elem.getAttribute(name) – получает значение атрибута.
elem.setAttribute(name, value) – устанавливает значение атрибута.
elem.removeAttribute(name) – удаляет атрибут.

<body something="non-standard">
  <script>
    alert(document.body.getAttribute('something')); // non-standard
  </script>
</body>
--
ИЗМЕНЕНИЕ ДОКУМЕНТА
DOM-узел(элемент) можно создать двумя способами:
1) Создание нового элемента с заданным тегом
document.createElement(tag) // let div = document.createElement('div');
2) Создает новый текстовый узел с заданным текстом:
let textNode = document.createTextNode('А вот и я');
У нас пример с созданием сообщения
let div = document.createElement('div');
div.className = "alert";
div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";
метод append() предназначен для вставки элемента в document
для удаления узлов предназначен метод remove() // div.remove()
--
КЛАССЫ
Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами. Но более предпочтительным является добавление/удаление классов. Для этого предназначено свойство elem.classList. elem.classList – это специальный объект с методами для добавления/удаления одного класса. Методами classList являются remove(), add(), contains() 
--
БРАУЗЕРНЫЕ СОБЫТИЯ  
Событие это сигнал от браузера о том, что что-то произошло
Обработчик события может быть назначен:
1)прямо в разметке, в атрибуте, который называется on<событие>, onclick()
2)с помощью свойства DOM-элемента, например elem.onclick
Внутри обработчика события this ссылается на текущий элемент, т.е на элемент, на котором произошло событие. Если мы задаем обработчие через DOM-свойство, то круглые скобки при записи функции ставить не надо, а если через HTML разметку, то круглые скобки необходимы.
Главный недостаток описанных выше способов в том, что они не не позволяют повесить более одного обработчика. Если мы хотим повесить множество обработчиков, то следует использовать addEventListener(), для того, чтобы убрать обработчик можно использовать removeEventListener(). addEventListener(event, handler, [options]). options - это объект со свойствами once, capture, passive
--
ВСПЛЫТИЕ И ПОГРУЖЕНИЕ
Всплытие - когда на элементе происходит событие, обработчики сначала срабатывают на нем, потом на его родителе, затем выше и так далее по цепочке предков.
<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
Клик по внутреннему <p> вызовет обработчик onclick:

Сначала на самом <p>.
Потом на внешнем <div>.
Затем на внешнем <form>.
И так далее вверх по цепочке до самого document.
Самый глубокий элемент, который вызывает событие доступен через event.target
target - то, на что мы кликнули
currentTarget - то, на что повешен обработчик событий
Для остановки всплытия используется метод event.stopPropagination(). То есть, event.stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.
Чтобы работать с погружением, в addEventListener надо использовать третий аргумент capture elem.addEventListener(..., true). Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
Если аргумент true, то событие будет перехвачено при погружении.
--
Для отмены стандартных действий браузера используется event.preventDefault()
--
ГЕНЕРАЦИЯ ПОЛЬЗОВАТЕЛЬСКИХ СОБЫТИЙ
Можно создавать событие через встроенный класс Event через new Event. let event = new Event(type, [object]). type - тип события, options - объект с тремя необяхательными свойствами (bubbles, cancelable, composed). По умолчанию все три уставновлены в false. После того как событие создано, мы должны его запустить на элементе с помощью dispatchEvent(event)
let event = new Event("click");
elem.dispatchEvent(event);
